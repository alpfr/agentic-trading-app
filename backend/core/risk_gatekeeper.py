import logging
import uuid
from typing import Tuple

from trading_interface.events.schemas import SignalCreated, RiskApproved, RiskRejected, RiskMetrics
from core.portfolio_state import PortfolioState, MarketContext

logger = logging.getLogger("RiskManagerGatekeeper")


class HardConstraintViolation(Exception):
    def __init__(self, metric: str, reason: str):
        self.metric = metric
        self.reason = reason
        super().__init__(reason)


class DeterministicRiskManager:
    """
    Absolutely impassable mathematical boundary.
    Any Signal generated by the LLM must survive these code-level blocks.
    """

    def __init__(self):
        # Drawdown / loss limits
        self.max_drawdown_pct    = 0.10   # 10% HWM drawdown kill-switch
        self.max_daily_loss      = 0.03   # 3% intraday circuit breaker

        # Position sizing constraints
        self.max_single_position = 0.05   # 5% max equity per ticker
        self.max_sector_exposure = 0.20   # 20% max sector correlation risk
        self.risk_per_trade_pct  = 0.01   # Risk exactly 1% of equity per trade

        # Liquidity & macro filters
        self.min_daily_volume       = 5_000_000  # 5M ADV floor
        self.max_vix                = 35.0        # No new longs in a panic
        self.earnings_blackout_days = 3           # Volatility crush prevention

    # ------------------------------------------------------------------
    # Public API
    # ------------------------------------------------------------------

    def evaluate_signal(
        self,
        signal: SignalCreated,
        portfolio: PortfolioState,
        market: MarketContext,
    ) -> RiskApproved | RiskRejected:
        """Central gatekeeper. Emits exactly one of: Approval | Rejection."""
        logger.info(f"Evaluating signal {signal.event_id} ({signal.ticker})")

        try:
            self._check_account_viability(portfolio)
            self._check_market_regimes(signal, market)
            self._check_portfolio_concentration(signal, portfolio, market.ticker)

            mapped_action = self._map_llm_action(signal.suggested_action)

            # SELL_TO_CLOSE — verify a long position actually exists before sizing
            if mapped_action == "SELL_TO_CLOSE":
                shares, total_value, stop_loss = self._size_close_order(
                    signal, portfolio, market
                )
            else:
                shares, total_value, stop_loss = self._compute_volatility_sizing(
                    signal, portfolio, market
                )

            return RiskApproved(
                event_id=uuid.uuid4(),
                signal_id=signal.event_id,
                ticker=signal.ticker,
                action=mapped_action,
                approved_quantity=shares,
                approved_limit_price=market.current_price,
                risk_metrics=RiskMetrics(
                    account_exposure_pct=round((total_value / portfolio.total_equity) * 100, 2),
                    volatility_atr=market.atr_14,
                    hard_stop_loss=stop_loss,
                ),
            )

        except HardConstraintViolation as v:
            logger.warning(f"RISK REJECTED: [Metric={v.metric}] {v.reason}")
            return RiskRejected(
                signal_id=signal.event_id,
                reason=v.reason,
                failing_metric=v.metric,
            )
        except Exception as e:
            logger.error(f"FATAL Risk engine crash: {e}")
            return RiskRejected(
                signal_id=signal.event_id,
                reason="Engine crashed during computation.",
                failing_metric="SYSTEM_ERROR",
            )

    # ------------------------------------------------------------------
    # Private Assertions
    # ------------------------------------------------------------------

    def _check_account_viability(self, portfolio: PortfolioState):
        if portfolio.is_trading_halted:
            raise HardConstraintViolation("HALTED_BY_ADMIN", "Manual halt/kill-switch active.")

        if portfolio.current_drawdown_pct >= self.max_drawdown_pct:
            raise HardConstraintViolation(
                "MAX_DRAWDOWN",
                f"HWM drawdown ({portfolio.current_drawdown_pct * 100:.1f}%) exceeds 10% limit.",
            )

        if portfolio.daily_loss_pct >= self.max_daily_loss:
            raise HardConstraintViolation("DAILY_LOSS", "Intraday 3% loss circuit breaker triggered.")

    def _check_market_regimes(self, signal: SignalCreated, market: MarketContext):
        if market.avg_daily_volume < self.min_daily_volume:
            raise HardConstraintViolation(
                "LIQUIDITY",
                f"ADV {market.avg_daily_volume:,} below 5M minimum.",
            )

        if market.days_to_earnings <= self.earnings_blackout_days:
            raise HardConstraintViolation(
                "EARNINGS_RISK",
                f"Trade violates {self.earnings_blackout_days}-day earnings blackout "
                f"(earnings in {market.days_to_earnings} days).",
            )

        if signal.suggested_action == "BUY" and market.vix_level > self.max_vix:
            raise HardConstraintViolation(
                "MACRO_VIX",
                f"VIX {market.vix_level} > {self.max_vix}. New longs disabled.",
            )

    def _check_portfolio_concentration(
        self, signal: SignalCreated, portfolio: PortfolioState, ticker: str
    ):
        for p in portfolio.positions:
            if p.ticker == ticker:
                exposure_pct = p.market_value / portfolio.total_equity
                if exposure_pct >= self.max_single_position:
                    raise HardConstraintViolation(
                        "SINGLE_LIMIT",
                        f"Already at max allocation ({exposure_pct * 100:.1f}%) in {ticker}.",
                    )

    def _compute_volatility_sizing(
        self,
        signal: SignalCreated,
        portfolio: PortfolioState,
        market: MarketContext,
    ) -> Tuple[int, float, float]:
        """
        1% equity risk per trade.
        Stop distance = 2 × ATR.
        Shares = Risk$ / Stop distance, capped at 5% nominal.
        """
        if market.atr_14 <= 0 or market.current_price <= 0:
            raise HardConstraintViolation("DATA_ERROR", "ATR or price is zero/negative.")

        risk_dollars       = portfolio.total_equity * self.risk_per_trade_pct
        stop_loss_distance = 2.0 * market.atr_14
        raw_shares         = int(risk_dollars // stop_loss_distance)

        if raw_shares == 0:
            raise HardConstraintViolation("TINY_RISK", "Stop dictates <1 share. Invalid balance.")

        total_allocation = raw_shares * market.current_price
        if total_allocation / portfolio.total_equity > self.max_single_position:
            max_capital      = portfolio.total_equity * self.max_single_position
            raw_shares       = int(max_capital // market.current_price)
            total_allocation = raw_shares * market.current_price

        if total_allocation > portfolio.buying_power:
            raise HardConstraintViolation("BUYING_POWER", "Insufficient uninvested liquidity.")

        # BUY: stop below entry | SHORT: stop above entry
        is_buy      = signal.suggested_action.upper() == "BUY"
        stop_trigger = (
            market.current_price - stop_loss_distance if is_buy
            else market.current_price + stop_loss_distance
        )

        return raw_shares, total_allocation, stop_trigger

    def _size_close_order(
        self,
        signal: SignalCreated,
        portfolio: PortfolioState,
        market: MarketContext,
    ) -> Tuple[int, float, float]:
        """
        For SELL_TO_CLOSE — close the entire existing long position.
        Raises HardConstraintViolation if no long position exists.
        """
        existing = next(
            (p for p in portfolio.positions if p.ticker == signal.ticker), None
        )
        if existing is None or existing.quantity <= 0:
            raise HardConstraintViolation(
                "NO_POSITION",
                f"Cannot SELL_TO_CLOSE {signal.ticker} — no open long position found.",
            )

        total_value = existing.quantity * market.current_price
        # Stop is not applicable for a closing order — set to 0.0
        return existing.quantity, total_value, 0.0

    def _map_llm_action(self, string_action: str) -> str:
        action = string_action.upper()
        if action == "BUY":  return "BUY_TO_OPEN"
        if action == "SELL": return "SELL_TO_CLOSE"
        if action == "HOLD": raise HardConstraintViolation("NO_ACTION", "HOLD carries no execution request.")
        raise HardConstraintViolation("INVALID_MAPPING", f"Unexpected action from LLM: '{string_action}'.")
